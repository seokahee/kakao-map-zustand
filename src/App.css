html {
  font-size: 62.5%;
}
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -ms-overflow-style: none;
}

::-webkit-scrollbar {
  display: none;
}

.wrap {
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: black;
  font-size: 1.5rem;

  user-select: none; /* 드래그 중 텍스트 선택 방지 */
}

/* 카카오 지도 */
.map {
  width: 100%;
  height: 100%;
}

.info-window-div {
  max-width: 30rem;
  padding: 0 0.5rem;
  white-space: nowrap;
}

.pointer-btn-wrap {
  display: flex;
  justify-content: center;
  gap: 2rem;
  position: absolute;
  top: 5%;
  right: 5%;
  z-index: 1;
  flex-direction: column;
}

.pointer-btn {
  max-width: 20rem;
  width: 100%;
  padding: 1rem;
  border-radius: 1rem;
  font-size: 1.6rem;
  border: none;
  cursor: pointer;
  box-shadow: 1px 1px 5px 0px black;
  background-color: #eee;
}

.pointer-btn:hover {
  background-color: black;
  color: #cccccc;
}

/* 바텀시트 */

.bottom-sheet-wrap {
  position: relative;
  overflow: hidden; /* 화면 밖으로 넘는 부분 숨기기 */
  z-index: 10;
}

.bottom-sheet {
  height: 100%; /* 바텀시트의 전체 높이 */
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0; /* 화면 하단에 고정 */
  background: #ffffff;
  box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
}

.sheet-header {
  height: 8%; /* 헤더의 높이 */
  background-color: #eee;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: grab;
}

.sheet-header:active {
  cursor: grabbing;
}

.sheet-handle {
  width: 30rem;
  height: 0.5rem;
  background-color: #aaa;
  border-radius: 10px;
}

.sheet-content-wrap {
  padding: 1rem;
  overflow-y: auto;
  max-height: calc(
    100vh - 10rem
  ); /* 최대 높이를 설정하여, 그 이상일 경우 스크롤이 생기도록 함 */
}

/* 시트 콘텐츠  */

.sheet-content {
  margin-bottom: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 8px;
  transition: transform 0.3s ease-out;
  background: #f9f9f9;
}

.sheet-content.drag-y {
  opacity: 0.5;
}

.content-item {
  width: 75%;
  display: flex;
  align-items: center;
  gap: 2rem;
  position: relative;

  cursor: pointer;
  /* -webkit-user-select: none;
  user-select: none; 텍스트 선택 효과 지우기 */
}

.content-item img {
  width: 15%;
  border-radius: 8px;
}

.content-txt {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.index-change-btn {
  width: 20%;
  height: 13vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #eee;
  cursor: grab;
}

.index-change-btn:active {
  cursor: grabbing;
}

.delete-btn {
  width: 6.6%;
  position: absolute;
  right: -7%;
  cursor: pointer;
  border-radius: 5px;
}

/*  */
/* .sheet-content {
  transition: transform 0.2s ease;
}

.sheet-content.dragging {
  opacity: 0.8;
  transform: scale(1.05);
  z-index: 10;
} */

/* 
Xy좌표겹침 이벤트종료
드롭오버 드래그엔드 함수 콘솔찍어 확인
기준상태 다시살피기
참조객체로 클래스부여방식으로 변경 */

/* dragItem.classList.add('dragged'); // 이동 중일 때 클래스 추가
dragItem.classList.remove('dragged'); // 이동 종료 시 클래스 제거 */

/* transform	요소를 이동, 회전, 크기 조정 등 변환을 수행하는 속성.	시각적 변경(이동, 회전, 크기 조정 등)
transition	속성 변경에 부드러운 애니메이션을 적용.	속성 변경 애니메이션
translate	transform의 하위 기능으로 요소를 X, Y, Z 축으로 이동.	위치 이동 */

/* 
const handleDrag = (e: React.DragEvent<HTMLDivElement>, id: string) => {
  if (!isDragging) return;

  const dragItem = contentRefs.current[id];
  if (dragItem) {
    const moveX = e.clientX - startX; // X축 차이
    const moveY = e.clientY - startY; // Y축 차이

    // X축 드래그
    if (Math.abs(moveX) > Math.abs(moveY)) {
      dragItem.style.transform = `translateX(${moveX}px)`; // X축 이동
    }

    // Y축 드래그
    if (Math.abs(moveY) > Math.abs(moveX)) {
      dragItem.classList.add("active"); // Y축 드래그 시 active 클래스 추가
      dragItem.style.transform = `translateY(${moveY}px)`; // Y축 이동
    }
  }

  // 다른 아이템들은 원위치로 돌림
  Object.keys(contentRefs.current).forEach((key) => {
    if (contentRefs.current[key]) {
      contentRefs.current[key]!.style.transform = "translateX(0)";
      contentRefs.current[key]!.classList.remove("active"); // active 클래스 제거
    }
  });

  console.log("handleDrag");
};

const handleDragOver = (e: React.DragEvent<HTMLDivElement>, id: string) => {
  e.preventDefault(); // 기본 동작 방지

  if (draggingItemId === id) return; // 동일한 아이템이 드래그 중일 경우 순서 변경 안 함

  const draggedIndex = storeMarkers.findIndex(
    (item) => item.id === draggingItemId
  ); // 드래그 대상 아이템이 원래 있던 위치
  const targetIndex = storeMarkers.findIndex((item) => item.id === id); // 드래그 대상 아이템이 들어갈 위치

  if (draggedIndex === targetIndex) return; // 같은 인덱스일 경우 변경하지 않음

  // 순서 변경
  const newMarkers = [...storeMarkers];
  const [removed] = newMarkers.splice(draggedIndex, 1); // 리스트에서 드래그된 아이템 제거
  newMarkers.splice(targetIndex, 0, removed); // 새 위치에 삽입
  setStoreMarkers(newMarkers);

  // 'active' 클래스 제거
  contentRefs.current[id]?.classList.remove("active");
}; */

/* 
const handleDrag = (e: React.DragEvent<HTMLDivElement>, id: string) => {
  if (!isDragging) return;

  const dragItem = contentRefs.current[id];
  if (dragItem) {
    // e.nativeEvent.offsetX는 드래그한 거리를 가져옵니다.
    const moveX = e.nativeEvent.offsetX;

    // transition을 추가하여 드래그 이동에 애니메이션 효과를 줍니다.
    dragItem.style.transition = "transform 0.3s ease-in-out"; 
    dragItem.style.transform = `translateX(${moveX}px)`; // 드래그한 만큼 이동
  }

  console.log("handleDrag");
};

const handleDragEnd = (e: React.DragEvent<HTMLDivElement>, id: string) => {
  const dragItem = contentRefs.current[id];
  if (dragItem) {
    // 드래그를 멈춘 후, 그 위치에서 멈추게 하기 위해 transition을 추가합니다.
    dragItem.style.transition = "transform 0.3s ease-in-out"; 
    // 드래그된 위치에서 멈추도록 합니다.
    dragItem.style.transform = `translateX(${e.nativeEvent.offsetX}px)`;
  }

  // 드래그 종료 후 상태 초기화
  contentRefs.current[id]?.classList.remove("index");
  setIsDragging(false); // 드래그 종료 상태 설정
  setDraggingItemId(null); // 드래그된 아이템 ID 초기화
}; */
